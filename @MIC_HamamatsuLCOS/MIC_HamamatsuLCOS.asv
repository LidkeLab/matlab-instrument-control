classdef MIC_HamamatsuLCOS < MIC_Abstract
    %MIC_HamamatsuLCOS Matlab Instrument Control of Hamamatsu LCOS SLM
    % This class controls a phase SLM connected through a DVI interface
    % 
    % Pupil diameter is 2*NA*f, f=M/180 for olympus objectives
    
    properties
        HorPixels=1272      %SLM Horizontal Pixels
        VerPixels=1024      %SLM Vertical Pixels
        PixelPitch=12.5     %Pixel Pitch (micron)
        Lambda=.69;         %Wavelength (micron)
        File_Correction='CAL_LSH0801531_690nm.bmp'     %Wavelength dependent phase correction file
        ScaleFactor=218/256;    %Input required for 2pi phase (default for 690 nm)
        
        Image_Correction    %Phase correction image
        Image_Blaze=0       %A Blaze Image
        Image_Pattern=0      %Desired phase (Image without Correction or Blaze)
        Image_Display       %Pattern to be diplayed on SLM
        Image_ZernikeStack  %Pre-calculated Zernike Images
        
        PupilCenter         %Location of pupil center (SLM Pixels)
        PupilRadius         %Pupil Radius (SLM Pixels)
        ZernikeCoef         %Zernike coefficients used to create Pattern
        
        Fig_Pattern         %Pattern Figure Object
        PrimaryDispSize;    %Number of pixels of primary display [Hor Ver]
        
        StartGUI=0;
    end
    
    properties (SetAccess=protected)
        InstrumentName='LCOS'; %Descriptive name of instrument.  Must be a valid Matlab varible name. 
    end
    
    
    
    
    methods
        function obj=MIC_HamamatsuLCOS()
            %Create object, load correction and setup window
            
            obj = obj@MIC_Abstract(~nargout)
            
            %Load in correction file
            obj.Image_Correction=double(imread(obj.File_Correction));
            
            %Setup SLM Figure window
            obj.setupImage();
            
            %Set default pattern to correction image
            obj.calcDisplayImage();
            
            %Diplay the correction image
            obj.displayImage();
            
        end
        
        function delete(obj)
            delete(obj.Fig_Pattern);
        end
        
        function gui()
        end
        
        function unitTest()
        end
        
        function [Attributes,Data,Children]=exportState(obj)
            %Export all important Attributes, Data and Children
            Attributes.HorPixels=obj.HorPixels;
            Attributes.VerPixels=obj.VerPixels;
            Attributes.File_Correction=obj.File_Correction;
            Attributes.ScaleFactor=obj.ScaleFactor;
            Attributes.ZernikeCoef=obj.ZernikeCoef;
            
            Data.Image_PatternRaw=obj.ImagePatternRaw;
            
            Children=[];
        end
        
        function setupImage(obj)
            %Create the figure that will display on the SLM
            ScrSz=get(0,'screensize');
            obj.PrimaryDispSize=ScrSz(3:4);
            delete(obj.Fig_Pattern);
            obj.Fig_Pattern=figure('Position',...
                [obj.PrimaryDispSize(1) obj.PrimaryDispSize(2)-obj.VerPixels...
                obj.HorPixels obj.VerPixels],...
                'MenuBar','none','ToolBar','none','resize','off')
            colormap(gray(256));
            %Prevent closing after a 'close' or 'close all'
            axis off
            set(gca,'position',[0 0 1 1],'Visible','off');
            obj.Fig_Pattern.HandleVisibility='off'; 
        end
        
        function displayImage(obj)
            % Displays Image_Pattern full screen on DVI output
            obj.Fig_Pattern.HandleVisibility='on';
            figure(obj.Fig_Pattern);
            image(obj.Image_Display);
            set(gca,'position',[0 0 1 1],'Visible','off');
            obj.Fig_Pattern.HandleVisibility='off';
            drawnow();
        end
        
        function calcZernikeImage(obj,ZernikeCoef)
            %Calculates Pattern based on ZernikeCoef
            
            %Get image from PSF class with size of 2*obj.PupilRadius
            RR=single(rr([obj.PupilRadius, obj.PupilRadius]*2));
            Mask=(RR<obj.PupilRadius);
            RR=Mask.*RR/obj.PupilRadius;
            dipshow(RR)
            
            obj.PupilCenter=[600,700]
            %Now put it in the right place
            Image=obj.Image_Correction*0;
            Image(obj.PupilCenter(1)-obj.PupilRadius:obj.PupilCenter(1)+obj.PupilRadius-1,...
                obj.PupilCenter(2)-obj.PupilRadius:obj.PupilCenter(2)+obj.PupilRadius-1)=...
                sqrt(3)*(2*RR.^2-1).*Mask;
            
        end
        
        function calcZernikeStack(obj)
            %Calculate a stack of images  
        end
        
        function calcDisplayImage(obj)
            %Blaze and Pattern images are input with the assumption 
            % that 2pi=256.  However, this is not exactly correct, and 
            % images are corrected here by the
            %scale factor. The resulting combintation is wrapped modulo 256
            %for display on the SLM.  
            obj.Image_Display=mod(obj.Image_Correction+...
                obj.ScaleFactor*obj.Image_Blaze+...
                obj.ScaleFactor*obj.Image_Pattern,256);
            
        end
        
        function calcBlazeImage(obj,BlazeAngle,ROI)
            %Calculates Pattern using a blaze angle
            % obj.calcBlazePattern(ROI,BlazeAngle)
            
            %ROI is [YStart XStart YWidth XWidth]
            
            if nargin<3 %make full image blaze
                ROI=[1 1 obj.VerPixels obj.HorPixels];
            end

            %Make empty image
            obj.Image_Blaze=zeros(obj.VerPixels,obj.HorPixels);
            L_SubIm=ROI(4)*obj.PixelPitch;
            Delay=L_SubIm*tan(BlazeAngle);
            Delay_Phase=Delay/obj.Lambda*256;
            
            SubIm=meshgrid(linspace(0,Delay_Phase,ROI(4)),1:ROI(3));
            obj.Image_Blaze(ROI(1):ROI(1)+ROI(3)-1,ROI(2):ROI(2)+ROI(4)-1)...
                =SubIm;
            
        end
        
        
        
    end
    
end

